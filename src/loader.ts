/**
 * OMP Tool Loader Generator
 *
 * Generates ~/.pi/agent/tools/omp/index.ts with hardcoded tool paths.
 * No symlinks needed - tools are imported directly from node_modules.
 */

import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { readPluginPackageJson } from "@omp/manifest";
import { getAgentDir, getPackageJsonPath } from "@omp/paths";

interface PluginInfo {
	tools?: string; // e.g. "@oh-my-pi/exa/tools"
	runtime?: string; // e.g. "@oh-my-pi/exa/tools/runtime.json"
}

/**
 * Get plugin info (tools and runtime paths) from installed plugins
 */
async function getPluginInfo(global: boolean): Promise<Map<string, PluginInfo>> {
	const pkgJsonPath = getPackageJsonPath(global);
	if (!existsSync(pkgJsonPath)) return new Map();

	const pkgJson = JSON.parse(readFileSync(pkgJsonPath, "utf-8"));
	const deps = { ...pkgJson.dependencies, ...pkgJson.devDependencies };

	const plugins = new Map<string, PluginInfo>();

	for (const pluginName of Object.keys(deps)) {
		const pluginPkgJson = await readPluginPackageJson(pluginName, global);
		if (!pluginPkgJson?.omp) continue;

		const info: PluginInfo = {};
		if (pluginPkgJson.omp.tools) {
			info.tools = `${pluginName}/${pluginPkgJson.omp.tools}`;
		}
		if (pluginPkgJson.omp.runtime) {
			info.runtime = `${pluginName}/${pluginPkgJson.omp.runtime}`;
		}

		if (info.tools || info.runtime) {
			plugins.set(pluginName, info);
		}
	}

	return plugins;
}

/**
 * Write the OMP loader with hardcoded tool paths and runtime redirects
 */
export async function writeLoader(global = true): Promise<void> {
	const agentDir = getAgentDir(global);
	const ompDir = join(agentDir, "tools", "omp");

	mkdirSync(ompDir, { recursive: true });

	const plugins = await getPluginInfo(global);
	const toolPaths = [...plugins.values()].filter((p) => p.tools).map((p) => `"${p.tools}"`);

	// Build runtime redirects: maps full module path to store filename
	// e.g., "@oh-my-pi/exa/tools/runtime.json" -> "@oh-my-pi__exa.json"
	const runtimeRedirects: string[] = [];
	for (const [name, info] of plugins) {
		if (info.runtime) {
			const storeName = name.replace(/\//g, "__"); // @oh-my-pi/exa -> @oh-my-pi__exa
			runtimeRedirects.push(`  ["${info.runtime}", "${storeName}.json"]`);
		}
	}

	const source = `/**
 * OMP Tool Loader
 *
 * Auto-generated by omp. Do not edit.
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";
import type { CustomToolFactory, CustomAgentTool } from "@mariozechner/pi-coding-agent";

// ============================================================================
// Tool registry (regenerated on plugin install/uninstall)
// ============================================================================

const toolPaths = [
${toolPaths.map((p) => ` ${p}`).join(",\n")}
];

// Runtime config: [moduleSpecifier, storeFilename]
const runtimeConfigs: [string, string][] = [
${runtimeRedirects.join(",\n")}
];

// ============================================================================
// Bootstrap: Patch module resolution and load runtime configs from store
// ============================================================================

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const piDir = path.resolve(__dirname, "../../.."); // ~/.pi
const pluginNodeModules = path.join(piDir, "plugins/node_modules");
const storeDir = path.join(piDir, "plugins/store");

// Ensure store directory exists
fs.mkdirSync(storeDir, { recursive: true });

if (fs.existsSync(pluginNodeModules)) {
   try {
      const Module = await import("node:module");
      const ModuleClass = (Module as any).default?.Module || (Module as any).Module;

      // Patch _nodeModulePaths to include plugins/node_modules
      if (ModuleClass?._nodeModulePaths) {
         const original = ModuleClass._nodeModulePaths;
         ModuleClass._nodeModulePaths = (from: string) => {
            const paths = original(from);
            if (!paths.includes(pluginNodeModules)) {
               paths.push(pluginNodeModules);
            }
            return paths;
         };
      }
   } catch (e) {
      console.error("omp-loader: Failed to patch module resolution:", e);
   }
}

// Load runtime configs: import module, read store, assign to module cache
for (const [moduleSpec, storeFile] of runtimeConfigs) {
   try {
      const runtime = await import(moduleSpec);
      const storePath = path.join(storeDir, storeFile);
      
      if (fs.existsSync(storePath)) {
         const storeData = JSON.parse(fs.readFileSync(storePath, "utf-8"));
         Object.assign(runtime.default, storeData);
      }
   } catch {
      // Module not found or store read failed - skip
   }
}

// ============================================================================
// Tool loader factory
// ============================================================================

const factory: CustomToolFactory = async (pi) => {
   const allTools: CustomAgentTool[] = [];

   for (const toolPath of toolPaths) {
      try {
         const module = await import(toolPath);
         const pluginFactory = module.default as CustomToolFactory;

         if (typeof pluginFactory !== "function") {
            console.error(\`omp-loader: \${toolPath} does not export a factory function\`);
            continue;
         }

         const result = await pluginFactory(pi);
         const resultTools = Array.isArray(result) ? result : [result];
         allTools.push(...resultTools);
      } catch (e) {
         console.error(\`omp-loader: Failed to load \${toolPath}:\`, e);
      }
   }

   return allTools;
};

export default factory;
`;

	writeFileSync(join(ompDir, "index.ts"), source, "utf-8");
}

/**
 * Check if the OMP loader exists
 */
export function loaderExists(global = true): boolean {
	const agentDir = getAgentDir(global);
	return existsSync(join(agentDir, "tools", "omp", "index.ts"));
}
